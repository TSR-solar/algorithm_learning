# 回溯
## 1. 0/1背包（子集树）
有n个物品，每个重量为`w[i]`，价值为`v[i]`。

现在要把物品装入容量为`W`的背包中，要求不超过容量的前提下，装入的物品价值尽可能的大，求最优解。

### 输入输出
输入：

第1行：物品个数n，背包容量W  
第2行：n个数，代表每个物品的重量w[i]  
第3行：n个数，代表每个物品的价值v[i]
```
4 6
5 3 2 1
4 4 3 1
```

输出：

第1行：最大价值  
第2行：其中一个最优解
```
8
2 3 4
```

### 问题求解
**回溯**：用递归保存当前状态。

**左剪枝**：超重时回溯。

**右剪枝**：已无法满足最优解时回溯。

`01.cpp`

## 2. 任务分配（排列树）
有n个任务分配给n个人，每个人只能选1个任务。  
第i个人执行第j个任务需要的时间为`c[i][j]`。

求所有人执行任务时间之和的最小值。

### 输入输出
输入：

第一行输入n。  
接下来n行，输入`c[n][n]`。
```
4
9 2 7 8
6 4 3 7
5 8 1 8
7 6 9 4
```

输出：

第一行，输出每个人分配的任务的编号。
第二行，输出时间之和的最小值。
```
13
2 1 3 4
```

### 问题求解
1. 先给第i个人分配任务i。
2. 交换第1个和第j个序号，产生固定前缀。
3. 对除去前缀的数组进行深入。到达叶子，则回溯。
4. 前缀已经不满足最优解时剪枝。